<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Multiplayer FPS Arena</title>
  <style>
    body { 
      margin: 0; 
      overflow: hidden; 
      font-family: 'Arial', sans-serif;
    }
    canvas { display: block; }
    
    #hud {
      position: absolute;
      top: 20px;
      left: 20px;
      color: white;
      font-size: 18px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
      pointer-events: none;
    }
    
    #health-bar {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      width: 300px;
      height: 30px;
      background: rgba(0,0,0,0.5);
      border: 2px solid white;
      border-radius: 15px;
      overflow: hidden;
    }
    
    #health-fill {
      height: 100%;
      background: linear-gradient(90deg, #ff0000, #00ff00);
      transition: width 0.3s;
      width: 100%;
    }
    
    #crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 20px;
      height: 20px;
      pointer-events: none;
    }
    
    #crosshair::before,
    #crosshair::after {
      content: '';
      position: absolute;
      background: white;
    }
    
    #crosshair::before {
      width: 2px;
      height: 20px;
      left: 9px;
    }
    
    #crosshair::after {
      width: 20px;
      height: 2px;
      top: 9px;
    }
    
    #kill-feed {
      position: absolute;
      top: 20px;
      right: 20px;
      color: white;
      font-size: 14px;
      text-align: right;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
      max-width: 300px;
    }
    
    .kill-msg {
      margin: 5px 0;
      opacity: 1;
      animation: fadeOut 5s forwards;
    }
    
    @keyframes fadeOut {
      0%, 70% { opacity: 1; }
      100% { opacity: 0; }
    }
    
    #ammo-counter {
      position: absolute;
      bottom: 30px;
      right: 30px;
      color: white;
      font-size: 24px;
      font-weight: bold;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
    }
    
    #debug {
      position: absolute;
      bottom: 80px;
      left: 20px;
      color: white;
      font-size: 12px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
    }
  </style>
</head>
<body>
<div id="hud">
  <div>Health: <span id="health-text">100</span></div>
  <div>Kills: <span id="kills">0</span></div>
  <div>Deaths: <span id="deaths">0</span></div>
</div>

<div id="health-bar">
  <div id="health-fill"></div>
</div>

<div id="crosshair"></div>

<div id="kill-feed"></div>

<div id="ammo-counter">
  <span id="ammo">30</span> / <span id="reserve">90</span>
</div>

<div id="debug">
  Players: <span id="player-count">0</span>
</div>

<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.module.js';
import opensockit from 'https://opensockit.onrender.com/opensockit.js';

const sockit = new opensockit();
await sockit.connect();

console.log('Connected to FPS Arena!');

// --- Game State ---
const gameState = {
  health: 100,
  maxHealth: 100,
  kills: 0,
  deaths: 0,
  ammo: 30,
  reserve: 90,
  isReloading: false
};

// Store player health states
const playerHealths = {};

// --- Scene Setup ---
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87CEEB);
scene.fog = new THREE.Fog(0x87CEEB, 0, 100);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.y = 1.7;

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

// --- Player Models ---
const players = {};
function createPlayerModel(color = 0x333333) {
  const group = new THREE.Group();
  
  // Body
  const bodyGeo = new THREE.BoxGeometry(0.6, 1, 0.4);
  const bodyMat = new THREE.MeshStandardMaterial({ color });
  const body = new THREE.Mesh(bodyGeo, bodyMat);
  body.position.y = 0.5;
  body.castShadow = true;
  group.add(body);
  
  // Head
  const headGeo = new THREE.BoxGeometry(0.4, 0.4, 0.4);
  const headMat = new THREE.MeshStandardMaterial({ color: 0xffdbac });
  const head = new THREE.Mesh(headGeo, headMat);
  head.position.y = 1.2;
  head.castShadow = true;
  group.add(head);
  
  // Arms
  const armGeo = new THREE.BoxGeometry(0.15, 0.6, 0.15);
  const armMat = new THREE.MeshStandardMaterial({ color: 0x555555 });
  
  const leftArm = new THREE.Mesh(armGeo, armMat);
  leftArm.position.set(-0.4, 0.4, 0);
  leftArm.castShadow = true;
  group.add(leftArm);
  
  const rightArm = new THREE.Mesh(armGeo, armMat);
  rightArm.position.set(0.4, 0.4, 0);
  rightArm.castShadow = true;
  group.add(rightArm);
  
  // Legs
  const legGeo = new THREE.BoxGeometry(0.2, 0.6, 0.2);
  const legMat = new THREE.MeshStandardMaterial({ color: 0x222222 });
  
  const leftLeg = new THREE.Mesh(legGeo, legMat);
  leftLeg.position.set(-0.15, -0.3, 0);
  leftLeg.castShadow = true;
  group.add(leftLeg);
  
  const rightLeg = new THREE.Mesh(legGeo, legMat);
  rightLeg.position.set(0.15, -0.3, 0);
  rightLeg.castShadow = true;
  group.add(rightLeg);
  
  // Health bar above head
  const healthBarBg = new THREE.Mesh(
    new THREE.PlaneGeometry(0.7, 0.1),
    new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.DoubleSide })
  );
  healthBarBg.position.y = 1.8;
  group.add(healthBarBg);
  
  const healthBarGeo = new THREE.PlaneGeometry(0.6, 0.08);
  const healthBarMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide });
  const healthBar = new THREE.Mesh(healthBarGeo, healthBarMat);
  healthBar.position.y = 1.8;
  healthBar.position.z = 0.01;
  group.add(healthBar);
  
  group.userData.healthBar = healthBar;
  group.userData.healthBarBg = healthBarBg;
  group.userData.health = 100;
  
  return group;
}

// --- Ground & Environment ---
const groundGeo = new THREE.PlaneGeometry(100, 100);
const groundMat = new THREE.MeshStandardMaterial({ color: 0x228B22 });
const ground = new THREE.Mesh(groundGeo, groundMat);
ground.rotation.x = -Math.PI/2;
ground.receiveShadow = true;
scene.add(ground);

// Add some cover
for(let i = 0; i < 15; i++) {
  const boxGeo = new THREE.BoxGeometry(2, 2, 2);
  const boxMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
  const box = new THREE.Mesh(boxGeo, boxMat);
  box.position.set(
    (Math.random() - 0.5) * 80,
    1,
    (Math.random() - 0.5) * 80
  );
  box.castShadow = true;
  box.receiveShadow = true;
  scene.add(box);
}

// --- Lighting ---
const ambient = new THREE.AmbientLight(0xffffff, 0.5);
scene.add(ambient);

const sun = new THREE.DirectionalLight(0xffffff, 0.8);
sun.position.set(50, 50, 50);
sun.castShadow = true;
sun.shadow.camera.left = -50;
sun.shadow.camera.right = 50;
sun.shadow.camera.top = 50;
sun.shadow.camera.bottom = -50;
scene.add(sun);

// --- Input ---
const keys = {};
const mouse = { x: 0, y: 0 };
let isPointerLocked = false;

document.addEventListener('keydown', e => {
  keys[e.key.toLowerCase()] = true;
  if(e.key.toLowerCase() === 'r' && !gameState.isReloading) reload();
});
document.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

document.addEventListener('click', () => {
  if(!isPointerLocked) {
    renderer.domElement.requestPointerLock();
  } else {
    shoot();
  }
});

document.addEventListener('pointerlockchange', () => {
  isPointerLocked = document.pointerLockElement === renderer.domElement;
});

document.addEventListener('mousemove', e => {
  if(isPointerLocked) {
    mouse.x += e.movementX * 0.002;
    mouse.y -= e.movementY * 0.002;
    mouse.y = Math.max(-Math.PI/2, Math.min(Math.PI/2, mouse.y));
  }
});

// --- Player Management ---
let playerId = null;

// Listen for new players
sockit.getSocket().on('userConnected', (data) => {
  const id = data.id || data;
  console.log('User connected:', id);
  
  if(!players[id] && id !== playerId) {
    const color = Math.random() * 0xffffff;
    players[id] = createPlayerModel(color);
    scene.add(players[id]);
    playerHealths[id] = 100;
    updatePlayerCount();
  }
});

// Listen for disconnects
sockit.getSocket().on('userDisconnected', (data) => {
  const id = data.id || data;
  console.log('User disconnected:', id);
  
  if(players[id]) {
    scene.remove(players[id]);
    delete players[id];
    delete playerHealths[id];
    updatePlayerCount();
  }
});

// Get my ID
playerId = sockit.getSocket().id;
console.log('My ID:', playerId);

// Create my player (invisible to self)
players[playerId] = createPlayerModel(0x0000ff);
players[playerId].visible = false;
scene.add(players[playerId]);
playerHealths[playerId] = 100;

function updatePlayerCount() {
  const count = Object.keys(players).length;
  document.getElementById('player-count').textContent = count;
}

updatePlayerCount();

// --- Multiplayer Sync ---
sockit.getSocket().on('move', (data) => {
  const {id, pos, rot} = data;
  
  if(!players[id]) {
    // Player doesn't exist yet, create them
    const color = Math.random() * 0xffffff;
    players[id] = createPlayerModel(color);
    scene.add(players[id]);
    playerHealths[id] = 100;
    updatePlayerCount();
  }
  
  if(id !== playerId && players[id]) {
    players[id].position.set(pos.x, pos.y, pos.z);
    players[id].rotation.y = rot;
  }
});

sockit.getSocket().on('shoot', (data) => {
  const {id, pos, dir} = data;
  createBullet(new THREE.Vector3(pos.x, pos.y, pos.z), new THREE.Vector3(dir.x, dir.y, dir.z), id);
  
  // Play muzzle flash effect
  if(players[id]) {
    const flash = new THREE.PointLight(0xffff00, 2, 5);
    flash.position.copy(players[id].position);
    flash.position.y = 1.5;
    scene.add(flash);
    setTimeout(() => scene.remove(flash), 50);
  }
});

sockit.getSocket().on('hit', (data) => {
  const {targetId, damage, shooterId} = data;
  console.log('Hit event:', data);
  
  if(targetId === playerId) {
    takeDamage(damage);
    
    // Check if dead
    if(gameState.health <= 0) {
      gameState.deaths++;
      document.getElementById('deaths').textContent = gameState.deaths;
      addKillFeed(shooterId, playerId);
      
      // Tell everyone I died
      sockit.send('playerDied', { victimId: playerId, killerId: shooterId });
      
      // Respawn after delay
      setTimeout(() => respawn(), 2000);
    }
  }
  
  // Update target's health bar
  if(players[targetId]) {
    playerHealths[targetId] = Math.max(0, (playerHealths[targetId] || 100) - damage);
    updatePlayerHealthBar(targetId);
  }
});

sockit.getSocket().on('playerDied', (data) => {
  const {victimId, killerId} = data;
  console.log('Player died:', data);
  
  if(killerId === playerId) {
    gameState.kills++;
    document.getElementById('kills').textContent = gameState.kills;
  }
  
  addKillFeed(killerId, victimId);
  
  // Reset victim's health
  if(playerHealths[victimId] !== undefined) {
    playerHealths[victimId] = 100;
    if(players[victimId]) {
      updatePlayerHealthBar(victimId);
    }
  }
});

sockit.getSocket().on('playerRespawned', (data) => {
  const {id} = data;
  if(playerHealths[id] !== undefined) {
    playerHealths[id] = 100;
    if(players[id]) {
      updatePlayerHealthBar(id);
    }
  }
});

// --- Health System ---
function takeDamage(amount) {
  gameState.health = Math.max(0, gameState.health - amount);
  updateHealthUI();
  
  // Flash red
  renderer.domElement.style.border = '5px solid red';
  setTimeout(() => renderer.domElement.style.border = 'none', 100);
}

function updateHealthUI() {
  document.getElementById('health-text').textContent = Math.ceil(gameState.health);
  document.getElementById('health-fill').style.width = (gameState.health / gameState.maxHealth * 100) + '%';
}

function updatePlayerHealthBar(id) {
  if(players[id] && players[id].userData.healthBar) {
    const health = playerHealths[id] || 100;
    const healthPercent = health / 100;
    
    players[id].userData.healthBar.scale.x = healthPercent;
    players[id].userData.healthBar.position.x = -(1 - healthPercent) * 0.3;
    
    players[id].userData.healthBar.material.color.setHex(
      healthPercent > 0.5 ? 0x00ff00 : healthPercent > 0.25 ? 0xffff00 : 0xff0000
    );
  }
}

function respawn() {
  gameState.health = gameState.maxHealth;
  gameState.ammo = 30;
  gameState.reserve = 90;
  updateHealthUI();
  updateAmmoUI();
  
  players[playerId].position.set(
    (Math.random() - 0.5) * 40,
    0,
    (Math.random() - 0.5) * 40
  );
  
  playerHealths[playerId] = 100;
  
  // Tell others I respawned
  sockit.send('playerRespawned', { id: playerId });
}

// --- Weapon System ---
function shoot() {
  if(gameState.ammo <= 0 || gameState.isReloading || gameState.health <= 0) return;
  
  gameState.ammo--;
  updateAmmoUI();
  
  const dir = new THREE.Vector3(0, 0, -1);
  dir.applyQuaternion(camera.quaternion);
  
  const bulletPos = camera.position.clone();
  createBullet(bulletPos, dir, playerId);
  
  // Broadcast shot
  sockit.send('shoot', { 
    id: playerId, 
    pos: { x: bulletPos.x, y: bulletPos.y, z: bulletPos.z },
    dir: { x: dir.x, y: dir.y, z: dir.z }
  });
  
  // Check for hits with raycasting
  const raycaster = new THREE.Raycaster(bulletPos, dir);
  
  for(let id in players) {
    if(id === playerId) continue;
    
    const intersects = raycaster.intersectObject(players[id], true);
    if(intersects.length > 0 && intersects[0].distance < 150) {
      const damage = 25;
      console.log('Hit player:', id, 'damage:', damage);
      
      // Send hit to everyone
      sockit.send('hit', { 
        targetId: id, 
        damage, 
        shooterId: playerId 
      });
      
      // Update local health
      playerHealths[id] = Math.max(0, (playerHealths[id] || 100) - damage);
      updatePlayerHealthBar(id);
      
      // Check if killed
      if(playerHealths[id] <= 0) {
        gameState.kills++;
        document.getElementById('kills').textContent = gameState.kills;
        addKillFeed(playerId, id);
        
        sockit.send('playerDied', { victimId: id, killerId: playerId });
        playerHealths[id] = 100;
      }
      
      break;
    }
  }
}

function reload() {
  if(gameState.reserve <= 0 || gameState.ammo === 30 || gameState.health <= 0) return;
  
  gameState.isReloading = true;
  setTimeout(() => {
    const needed = 30 - gameState.ammo;
    const toReload = Math.min(needed, gameState.reserve);
    gameState.ammo += toReload;
    gameState.reserve -= toReload;
    gameState.isReloading = false;
    updateAmmoUI();
  }, 1500);
}

function updateAmmoUI() {
  document.getElementById('ammo').textContent = gameState.ammo;
  document.getElementById('reserve').textContent = gameState.reserve;
}

// --- Bullets ---
const bullets = [];
function createBullet(pos, dir, shooterId) {
  const geo = new THREE.SphereGeometry(0.15, 8, 8);
  const mat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
  const bullet = new THREE.Mesh(geo, mat);
  bullet.position.copy(pos);
  bullet.userData.dir = dir.clone().normalize().multiplyScalar(2);
  bullet.userData.shooterId = shooterId;
  bullet.userData.life = 75;
  scene.add(bullet);
  bullets.push(bullet);
}

function addKillFeed(killerId, victimId) {
  const feed = document.getElementById('kill-feed');
  const msg = document.createElement('div');
  msg.className = 'kill-msg';
  const killerName = killerId === playerId ? 'You' : `Player ${killerId.slice(0,4)}`;
  const victimName = victimId === playerId ? 'You' : `Player ${victimId.slice(0,4)}`;
  msg.textContent = `${killerName} eliminated ${victimName}`;
  feed.insertBefore(msg, feed.firstChild);
  
  setTimeout(() => msg.remove(), 5000);
}

// --- Animation Loop ---
function animate() {
  requestAnimationFrame(animate);

  if(!players[playerId]) return;

  // Player movement (only if alive)
  if(gameState.health > 0) {
    const speed = 0.15;
    const forward = new THREE.Vector3(0, 0, -1);
    forward.applyAxisAngle(new THREE.Vector3(0, 1, 0), mouse.x);
    
    const right = new THREE.Vector3(1, 0, 0);
    right.applyAxisAngle(new THREE.Vector3(0, 1, 0), mouse.x);
    
    if(keys['w']) {
      players[playerId].position.add(forward.multiplyScalar(speed));
    }
    if(keys['s']) {
      players[playerId].position.add(forward.multiplyScalar(-speed));
    }
    if(keys['a']) {
      players[playerId].position.add(right.multiplyScalar(-speed));
    }
    if(keys['d']) {
      players[playerId].position.add(right.multiplyScalar(speed));
    }
    
    // Clamp position
    players[playerId].position.x = Math.max(-45, Math.min(45, players[playerId].position.x));
    players[playerId].position.z = Math.max(-45, Math.min(45, players[playerId].position.z));
    
    // Send position frequently
    sockit.send('move', { 
      id: playerId, 
      pos: { 
        x: players[playerId].position.x, 
        y: players[playerId].position.y, 
        z: players[playerId].position.z 
      },
      rot: mouse.x
    });
  }

  // Update camera
  camera.position.copy(players[playerId].position);
  camera.position.y = 1.7;
  camera.rotation.order = 'YXZ';
  camera.rotation.y = mouse.x;
  camera.rotation.x = mouse.y;

  // Update bullets
  for(let i = bullets.length - 1; i >= 0; i--) {
    const b = bullets[i];
    b.position.add(b.userData.dir);
    b.userData.life--;
    
    if(b.userData.life <= 0 || Math.abs(b.position.x) > 50 || Math.abs(b.position.z) > 50) {
      scene.remove(b);
      bullets.splice(i, 1);
    }
  }
  
  // Make health bars face camera
  for(let id in players) {
    if(players[id].userData.healthBar) {
      players[id].userData.healthBar.lookAt(camera.position);
      players[id].userData.healthBarBg.lookAt(camera.position);
    }
  }

  renderer.render(scene, camera);
}

animate();

// Handle window resize
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

</script>
</body>
</html>
